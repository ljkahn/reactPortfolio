(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "tsparticles-engine"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TextDrawer = exports.validTypes = void 0;
    const tsparticles_engine_1 = require("tsparticles-engine");
    exports.validTypes = ["text", "character", "char"];
    class TextDrawer {
        draw(context, particle, radius, opacity) {
            const character = particle.shapeData;
            if (character === undefined) {
                return;
            }
            const textData = character.value;
            if (textData === undefined) {
                return;
            }
            if (particle.text === undefined) {
                particle.text = (0, tsparticles_engine_1.itemFromSingleOrMultiple)(textData, particle.randomIndexData);
            }
            const text = particle.text, style = character.style ?? "", weight = character.weight ?? "400", size = Math.round(radius) * 2, font = character.font ?? "Verdana", fill = particle.fill, offsetX = (text.length * radius) / 2;
            context.font = `${style} ${weight} ${size}px "${font}"`;
            const pos = {
                x: -offsetX,
                y: radius / 2,
            };
            context.globalAlpha = opacity;
            if (fill) {
                context.fillText(text, pos.x, pos.y);
            }
            else {
                context.strokeText(text, pos.x, pos.y);
            }
            context.globalAlpha = 1;
        }
        getSidesCount() {
            return 12;
        }
        async init(container) {
            const options = container.actualOptions;
            if (exports.validTypes.find((t) => (0, tsparticles_engine_1.isInArray)(t, options.particles.shape.type))) {
                const shapeOptions = exports.validTypes
                    .map((t) => options.particles.shape.options[t])
                    .find((t) => !!t), promises = [];
                (0, tsparticles_engine_1.executeOnSingleOrMultiple)(shapeOptions, (shape) => {
                    promises.push((0, tsparticles_engine_1.loadFont)(shape.font, shape.weight));
                });
                await Promise.all(promises);
            }
        }
        particleInit(container, particle) {
            if (!particle.shape || !exports.validTypes.includes(particle.shape)) {
                return;
            }
            const character = particle.shapeData;
            if (character === undefined) {
                return;
            }
            const textData = character.value;
            if (textData === undefined) {
                return;
            }
            particle.text = (0, tsparticles_engine_1.itemFromSingleOrMultiple)(textData, particle.randomIndexData);
        }
    }
    exports.TextDrawer = TextDrawer;
});
